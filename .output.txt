diff --git a/src/domain/models.py b/src/domain/models.py
index dad28c6..ae66bda 100644
--- a/src/domain/models.py
+++ b/src/domain/models.py
@@ -27,6 +27,8 @@ class MapMetadata(BaseModel):
     original_cp_x_gk: float | None = None
     original_cp_y_gk: float | None = None
     helmert_params: tuple[float, float, float, float, float, float, float] | None = None
+    # Zoom уровень для высотных тайлов (для запроса высоты в информере)
+    elevation_zoom: int | None = None


 class MapSettings(BaseModel):
diff --git a/src/gui/view.py b/src/gui/view.py
index afdc7a7..99d4546 100644
--- a/src/gui/view.py
+++ b/src/gui/view.py
@@ -92,6 +92,7 @@ from geo.topography import (
     latlng_to_pixel_xy,
     pixel_xy_to_latlng,
 )
+from services.elevation_query import get_elevation_at_wgs84
 from shared.constants import CONTROL_POINT_PRECISION_TOLERANCE_M

 logger = logging.getLogger(__name__)
@@ -1329,7 +1330,7 @@ class MainWindow(QMainWindow):

     @Slot(object, object)
     def _on_mouse_moved_on_map(self, px: float | None, py: float | None) -> None:
-        """Handle mouse movement over preview to show SK-42 coordinates."""
+        """Handle mouse movement over preview to show SK-42 coordinates and elevation."""
         coords = self._calculate_sk42_from_scene_pos(px, py)
         if coords is None:
             self._coords_label.setText('')
@@ -1346,9 +1347,14 @@ class MainWindow(QMainWindow):
                 )
             return s

-        self._coords_label.setText(
-            f'X: {format_coord(x_val)}  Y: {format_coord(y_val)}'
-        )
+        coord_text = f'X: {format_coord(x_val)}  Y: {format_coord(y_val)}'
+
+        # Get elevation at cursor position
+        elevation = self._get_elevation_at_cursor(px, py)
+        if elevation is not None:
+            coord_text += f'  h = {elevation:.0f} м'
+
+        self._coords_label.setText(coord_text)

     def _calculate_sk42_from_scene_pos(
         self, px: float | None, py: float | None
@@ -1409,6 +1415,51 @@ class MainWindow(QMainWindow):
             logger.exception('Failed to calculate SK-42 coordinates from pixel')
             return None

+    def _get_elevation_at_cursor(
+        self, px: float | None, py: float | None
+    ) -> float | None:
+        """Get elevation at cursor position from cached terrain tiles."""
+        if px is None or py is None:
+            return None
+
+        metadata = self._model.state.last_map_metadata
+        if not metadata or metadata.elevation_zoom is None:
+            return None
+
+        try:
+            # Convert scene pixel to WGS-84 coordinates
+            cx_px = metadata.width_px / 2.0
+            cy_px = metadata.height_px / 2.0
+
+            dx_px = px - cx_px
+            dy_px = py - cy_px
+
+            # Account for rotation (inverse transform)
+            rotation_rad = math.radians(-metadata.rotation_deg)
+            cos_rot = math.cos(rotation_rad)
+            sin_rot = math.sin(rotation_rad)
+
+            dx = dx_px * cos_rot + dy_px * sin_rot
+            dy = -dx_px * sin_rot + dy_px * cos_rot
+
+            # Convert to world pixels
+            cx_world, cy_world = latlng_to_pixel_xy(
+                metadata.center_lat_wgs, metadata.center_lng_wgs, metadata.zoom
+            )
+
+            x_world = dx / metadata.scale + cx_world
+            y_world = dy / metadata.scale + cy_world
+
+            # Convert to WGS-84
+            lat_wgs, lng_wgs = pixel_xy_to_latlng(x_world, y_world, metadata.zoom)
+
+            # Query elevation from cache
+            return get_elevation_at_wgs84(lat_wgs, lng_wgs, metadata)
+
+        except Exception:
+            logger.debug('Failed to get elevation at cursor', exc_info=True)
+            return None
+
     @Slot(float, float)
     def _on_map_right_clicked(self, px: float, py: float) -> None:
         """Transfer coordinates from map right-click to control point settings."""
diff --git a/src/services/map_context.py b/src/services/map_context.py
index d62a72c..2aef261 100644
--- a/src/services/map_context.py
+++ b/src/services/map_context.py
@@ -91,6 +91,9 @@ class MapDownloadContext:
     # Tile size settings
     full_eff_tile_px: int = 512

+    # Elevation zoom level for informer (set after elevation tiles download)
+    elevation_zoom: int | None = None
+
     def to_metadata(self) -> MapMetadata:
         """Сборка метаданных для информера координат."""
         return MapMetadata(
@@ -114,6 +117,7 @@ class MapDownloadContext:
             if self.settings.control_point_enabled
             else None,
             helmert_params=self.settings.custom_helmert,
+            elevation_zoom=self.elevation_zoom,
         )

     def get_meters_per_pixel(self) -> float:
diff --git a/src/services/map_download_service.py b/src/services/map_download_service.py
index 3ae48aa..c1a4b9b 100644
--- a/src/services/map_download_service.py
+++ b/src/services/map_download_service.py
@@ -49,6 +49,7 @@ from services.map_postprocessing import (
     draw_center_cross_on_image,
     draw_control_point_triangle,
 )
+from elevation.provider import ElevationTileProvider
 from services.processors.elevation_contours import (
     apply_contours_to_image,
 )
@@ -149,6 +150,9 @@ class MapDownloadService:
                 # Select and run processor
                 ctx.result = await self._run_processor(ctx)

+                # Download elevation tiles for informer (if not already downloaded)
+                await self._ensure_elevation_tiles(ctx)
+
                 # Post-processing (may require network for overlay contours)
                 await self._postprocess(ctx)

@@ -408,6 +412,53 @@ class MapDownloadService:
         module = importlib.import_module('services.processors.xyz_tiles')
         return await module.process_xyz_tiles(ctx)

+    async def _ensure_elevation_tiles(self, ctx: MapDownloadContext) -> None:
+        """
+        Ensure elevation tiles are downloaded for the informer.
+
+        For maps that already use elevation data (ELEVATION_COLOR, ELEVATION_CONTOURS,
+        RADIO_HORIZON), the tiles are already cached. For other map types (SATELLITE,
+        HYBRID, STREETS, OUTDOORS), we need to download them separately.
+        """
+        # If elevation tiles were already downloaded by processor, just set the zoom
+        if ctx.is_elev_color or ctx.is_elev_contours or ctx.is_radio_horizon:
+            ctx.elevation_zoom = ctx.zoom
+            return
+
+        # For overlay contours, tiles are also already downloaded
+        if ctx.overlay_contours:
+            ctx.elevation_zoom = ctx.zoom
+            return
+
+        # Download elevation tiles for informer
+        logger.info('Загрузка высотных тайлов для информера — старт')
+        sp = LiveSpinner('Загрузка высот для информера')
+        sp.start()
+
+        try:
+            provider = ElevationTileProvider(
+                client=ctx.client,
+                api_key=ctx.api_key,
+                use_retina=ELEVATION_USE_RETINA,
+                cache_root=_resolve_cache_dir(),
+            )
+
+            # Download tiles concurrently
+            async def fetch_tile(tile: tuple[int, int]) -> None:
+                xw, yw = tile
+                await provider.get_tile_image(ctx.zoom, xw, yw)
+
+            tasks = [fetch_tile(tile) for tile in ctx.tiles]
+            await asyncio.gather(*tasks)
+
+            ctx.elevation_zoom = ctx.zoom
+            logger.info('Загрузка высотных тайлов для информера — завершена')
+        except Exception as e:
+            logger.warning('Не удалось загрузить высотные тайлы для информера: %s', e)
+            # Don't fail the whole operation, just leave elevation_zoom as None
+        finally:
+            sp.stop('Загрузка высот завершена')
+
     async def _postprocess(self, ctx: MapDownloadContext) -> None:
         """Apply post-processing to the result image."""
         result = ctx.result