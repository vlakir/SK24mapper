diff --git a/src/constants.py b/src/constants.py
index f642fcb..14d58ec 100644
--- a/src/constants.py
+++ b/src/constants.py
@@ -49,8 +49,8 @@ ADDITIVE_RATIO = 0.3
 # Шаг километровой сетки (метры)
 GRID_STEP_M = 1000

-# Длина линий крестиков при отключенной сетке (пиксели)
-GRID_CROSS_LENGTH_PX = 50
+# Длина линий крестиков при отключенной сетке (метры)
+GRID_CROSS_LENGTH_M = 50

 # Минимальное количество точек для рисования линии (draw.line требует >= 2)
 MIN_POINTS_FOR_LINE = 2
@@ -122,7 +122,7 @@ MAP_TYPE_LABELS_RU: dict[MapType, str] = {
     MapType.ELEVATION_COLOR: 'Карта высот (цветовая шкала)',
     MapType.ELEVATION_CONTOURS: 'Карта высот (контуры)',
     MapType.ELEVATION_HILLSHADE: 'Карта высот (hillshade)',
-    MapType.RADIO_HORIZON: 'Радиогоризонт',
+    MapType.RADIO_HORIZON: 'Радиогоризонт НСУ БпЛА',
 }

 # Резолвер для стилевых карт (этап 1)
@@ -221,6 +221,8 @@ ELEV_PCTL_LO = 2.0
 ELEV_PCTL_HI = 98.0
 # Запас для защиты от плоских регионов (минимальная дельта высот в метрах)
 ELEV_MIN_RANGE_M = 10.0
+# Шаг округления высот для легенды и палитры (метры)
+ELEVATION_LEGEND_STEP_M = 10.0
 # Палитра: список контрольных точек (t in [0,1], (R,G,B))
 ELEVATION_COLOR_RAMP = [
     (0.00, (0, 0, 130)),  # deep blue
@@ -264,8 +266,10 @@ CONTOUR_LABELS_ENABLED = True
 CONTOUR_LABEL_INDEX_ONLY = False
 # Интервал между подписями в метрах (пересчитывается в пиксели по текущему масштабу)
 CONTOUR_LABEL_SPACING_M = 1000
-CONTOUR_LABEL_MIN_SEG_LEN_PX = 40
-CONTOUR_LABEL_EDGE_MARGIN_PX = 8
+# Минимальная длина сегмента для размещения подписи (метры)
+CONTOUR_LABEL_MIN_SEG_LEN_M = 40
+# Отступ подписей от границ изображения (метры)
+CONTOUR_LABEL_EDGE_MARGIN_M = 8
 CONTOUR_LABEL_TEXT_COLOR = (20, 20, 20)
 CONTOUR_LABEL_OUTLINE_COLOR = (255, 255, 255)
 CONTOUR_LABEL_OUTLINE_WIDTH = 0
@@ -277,8 +281,8 @@ CONTOUR_LABEL_BG_PADDING = 3
 # --- Разрывы линий контуров для подписей
 # Включить разрывы линий в местах размещения подписей
 CONTOUR_LABEL_GAP_ENABLED = True
-# Дополнительный отступ вокруг подписей для разрыва линии (пиксели)
-CONTOUR_LABEL_GAP_PADDING = 5
+# Дополнительный отступ вокруг подписей для разрыва линии (метры)
+CONTOUR_LABEL_GAP_PADDING_M = 5

 # Старый фиксированный размер (для бэкапа/совместимости)
 CONTOUR_LABEL_FONT_SIZE = 18
@@ -328,10 +332,10 @@ PSUTIL_AVAILABLE = True
 # --- Центрированный крест на карте
 # Цвет креста (RGB)
 CENTER_CROSS_COLOR = (255, 255, 255)
-# Толщина линий креста (пиксели)
-CENTER_CROSS_LINE_WIDTH_PX = 1
-# Полная длина линии креста (пиксели)
-CENTER_CROSS_LENGTH_PX = 40
+# Толщина линий креста (метры)
+CENTER_CROSS_LINE_WIDTH_M = 1
+# Полная длина линии креста (метры)
+CENTER_CROSS_LENGTH_M = 40

 # --- Контрольная точка: единый стиль — красный треугольник с подписью
 # Размер контрольной точки (треугольника) в метрах на местности
@@ -400,6 +404,9 @@ CONTOUR_LOG_MEMORY_EVERY_TILES = 50
 # --- Легенда высот на карте (elevation legend)
 # Желаемая высота легенды как доля от высоты карты (10%)
 LEGEND_HEIGHT_RATIO = 0.10
+# Минимальная/максимальная высота легенды как доля от высоты карты
+LEGEND_HEIGHT_MIN_RATIO = 0.10
+LEGEND_HEIGHT_MAX_RATIO = 0.50
 # Минимальная высота легенды в километровых квадратах (для карт ниже порога высоты)
 LEGEND_MIN_HEIGHT_GRID_SQUARES = 1.0
 # Порог высоты карты (в километрах), ниже которого легенда занимает минимум 1 км-квадрат
@@ -411,27 +418,29 @@ LEGEND_WIDTH_TO_HEIGHT_RATIO = 0.133  # ширина = высота * 0.133
 LEGEND_MARGIN_RATIO = 0.067  # margin = высота_легенды * 0.067
 # Количество меток высоты на легенде (мин, макс и промежуточные)
 LEGEND_NUM_LABELS = 5
-# Отступ текста от цветовой полосы легенды в пикселях
-LEGEND_TEXT_OFFSET_PX = 5
-# Толщина рамки вокруг цветовой полосы легенды в пикселях
-LEGEND_BORDER_WIDTH_PX = 2
+# Отступ текста от цветовой полосы легенды в метрах
+LEGEND_TEXT_OFFSET_M = 5
+# Толщина рамки вокруг цветовой полосы легенды в метрах
+LEGEND_BORDER_WIDTH_M = 2
 # Размер шрифта для подписей легенды как доля от высоты легенды (увеличено в 2 раза)
 LEGEND_LABEL_FONT_RATIO = 0.26  # размер_шрифта = высота_легенды * 0.26
 # Диапазон размера шрифта подписей легенды в пикселях (мин и макс, увеличено в 2 раза)
 LEGEND_LABEL_FONT_MIN_PX = 24
 LEGEND_LABEL_FONT_MAX_PX = 96
-# Толщина обводки текста легенды в пикселях
-LEGEND_TEXT_OUTLINE_WIDTH_PX = 2
-# Дополнительный отступ вокруг легенды для разрыва линий сетки (пиксели)
-LEGEND_GRID_GAP_PADDING_PX = 10
+# Толщина обводки текста легенды в метрах
+LEGEND_TEXT_OUTLINE_WIDTH_M = 2
+# Дополнительный отступ вокруг легенды для разрыва линий сетки (метры)
+LEGEND_GRID_GAP_PADDING_M = 10
 # Цвет фона легенды (RGBA): белый полупрозрачный для визуального выделения
 LEGEND_BACKGROUND_COLOR = (255, 255, 255, 230)
-# Отступ фона легенды от краёв цветовой полосы (пиксели)
-LEGEND_BACKGROUND_PADDING_PX = 8
+# Отступ фона легенды от краёв цветовой полосы (метры)
+LEGEND_BACKGROUND_PADDING_M = 8
 # Горизонтальная позиция легенды: доля от ширины последнего километрового квадрата (0.5 = середина)
 LEGEND_HORIZONTAL_POSITION_RATIO = 0.5
 # Вертикальный отступ нижней границы легенды от первой горизонтальной линии сетки (в долях от шага сетки)
 LEGEND_VERTICAL_OFFSET_RATIO = 0.15
+# Дополнительный отступ заголовка легенды вверх (доля от высоты легенды)
+LEGEND_TITLE_OFFSET_RATIO = 0.10

 # --- Радиогоризонт (Radio Horizon)
 # Использовать ретина-тайлы для радиогоризонта (False = 256px, экономит память в 4 раза)
diff --git a/src/contours_labels.py b/src/contours_labels.py
index 2bc5227..34e9f8a 100644
--- a/src/contours_labels.py
+++ b/src/contours_labels.py
@@ -10,7 +10,7 @@ from constants import (
     CONTOUR_INDEX_EVERY,
     CONTOUR_LABEL_BG_PADDING,
     CONTOUR_LABEL_BG_RGBA,
-    CONTOUR_LABEL_EDGE_MARGIN_PX,
+    CONTOUR_LABEL_EDGE_MARGIN_M,
     CONTOUR_LABEL_FONT_BOLD,
     CONTOUR_LABEL_FONT_KM,
     CONTOUR_LABEL_FONT_MAX_PX,
@@ -19,7 +19,7 @@ from constants import (
     CONTOUR_LABEL_FONT_SIZE,
     CONTOUR_LABEL_FORMAT,
     CONTOUR_LABEL_INDEX_ONLY,
-    CONTOUR_LABEL_MIN_SEG_LEN_PX,
+    CONTOUR_LABEL_MIN_SEG_LEN_M,
     CONTOUR_LABEL_OUTLINE_COLOR,
     CONTOUR_LABEL_OUTLINE_WIDTH,
     CONTOUR_LABEL_SPACING_M,
@@ -133,10 +133,12 @@ def draw_contour_labels(
         return not (ax1 <= bx0 or bx1 <= ax0 or ay1 <= by0 or by1 <= ay0)

     spacing_px = max(1, round(CONTOUR_LABEL_SPACING_M / max(1e-9, mpp)))
+    min_seg_px = max(1, round(CONTOUR_LABEL_MIN_SEG_LEN_M / max(1e-9, mpp)))
+    edge_margin_px = max(1, round(CONTOUR_LABEL_EDGE_MARGIN_M / max(1e-9, mpp)))

     logger.info(
         'Подписи изолиний: старт (levels=%d, img=%dx%d, seed_ds=%d, dry_run=%s). '
-        'Пороги: spacing_m=%.1f (spacing_px=%d), min_seg=%d, edge=%d, outline=%d, gap_bg=%s',
+        'Пороги: spacing_m=%.1f (spacing_px=%d), min_seg_m=%.1f (min_seg_px=%d), edge_m=%.1f (edge_px=%d), outline=%d, gap_bg=%s',
         len(levels),
         w,
         h,
@@ -144,8 +146,10 @@ def draw_contour_labels(
         dry_run,
         float(CONTOUR_LABEL_SPACING_M),
         int(spacing_px),
-        int(CONTOUR_LABEL_MIN_SEG_LEN_PX),
-        int(CONTOUR_LABEL_EDGE_MARGIN_PX),
+        float(CONTOUR_LABEL_MIN_SEG_LEN_M),
+        int(min_seg_px),
+        float(CONTOUR_LABEL_EDGE_MARGIN_M),
+        int(edge_margin_px),
         int(CONTOUR_LABEL_OUTLINE_WIDTH),
         bool(CONTOUR_LABEL_BG_RGBA),
     )
@@ -190,9 +194,7 @@ def draw_contour_labels(
                 length = math.hypot(dx, dy)
                 seg_l_list.append(length)
                 total_len += length
-            if total_len < max(
-                CONTOUR_LABEL_MIN_SEG_LEN_PX, spacing_px * 0.8
-            ):
+            if total_len < max(min_seg_px, spacing_px * 0.8):
                 level_skipped_short += 1
                 total_skipped_short += 1
                 continue
@@ -228,12 +230,8 @@ def draw_contour_labels(
                     ang_rad -= math.pi

                 if not (
-                    CONTOUR_LABEL_EDGE_MARGIN_PX
-                    <= px
-                    <= w - CONTOUR_LABEL_EDGE_MARGIN_PX
-                    and CONTOUR_LABEL_EDGE_MARGIN_PX
-                    <= py
-                    <= h - CONTOUR_LABEL_EDGE_MARGIN_PX
+                    edge_margin_px <= px <= w - edge_margin_px
+                    and edge_margin_px <= py <= h - edge_margin_px
                 ):
                     level_skipped_edge += 1
                     total_skipped_edge += 1
diff --git a/src/gui/view.py b/src/gui/view.py
index efb1d2d..dd3bd0a 100644
--- a/src/gui/view.py
+++ b/src/gui/view.py
@@ -806,7 +806,7 @@ class MainWindow(QMainWindow):
         self._maptype_order = [
             MapType.SATELLITE,
             MapType.HYBRID,
-            MapType.STREETS,
+            # MapType.STREETS,
             MapType.OUTDOORS,
             MapType.ELEVATION_COLOR,
             # MapType.ELEVATION_HILLSHADE,
diff --git a/src/image.py b/src/image.py
index dd16de2..181ded3 100644
--- a/src/image.py
+++ b/src/image.py
@@ -7,7 +7,7 @@ from pyproj import CRS, Transformer

 from constants import (
     GRID_COLOR,
-    GRID_CROSS_LENGTH_PX,
+    GRID_CROSS_LENGTH_M,
     GRID_FONT_BOLD,
     GRID_FONT_PATH,
     GRID_FONT_PATH_BOLD,
@@ -19,8 +19,11 @@ from constants import (
     GRID_TEXT_OUTLINE_COLOR,
     GRID_TEXT_OUTLINE_WIDTH,
     LEGEND_BACKGROUND_COLOR,
-    LEGEND_BORDER_WIDTH_PX,
-    LEGEND_GRID_GAP_PADDING_PX,
+    LEGEND_BACKGROUND_PADDING_M,
+    LEGEND_BORDER_WIDTH_M,
+    LEGEND_GRID_GAP_PADDING_M,
+    LEGEND_HEIGHT_MAX_RATIO,
+    LEGEND_HEIGHT_MIN_RATIO,
     LEGEND_HEIGHT_RATIO,
     LEGEND_HORIZONTAL_POSITION_RATIO,
     LEGEND_LABEL_FONT_MAX_PX,
@@ -30,8 +33,9 @@ from constants import (
     LEGEND_MIN_HEIGHT_GRID_SQUARES,
     LEGEND_MIN_MAP_HEIGHT_KM_FOR_RATIO,
     LEGEND_NUM_LABELS,
-    LEGEND_TEXT_OFFSET_PX,
-    LEGEND_TEXT_OUTLINE_WIDTH_PX,
+    LEGEND_TEXT_OFFSET_M,
+    LEGEND_TEXT_OUTLINE_WIDTH_M,
+    LEGEND_TITLE_OFFSET_RATIO,
     LEGEND_VERTICAL_OFFSET_RATIO,
     LEGEND_WIDTH_TO_HEIGHT_RATIO,
     MIN_POINTS_FOR_LINE,
@@ -535,7 +539,8 @@ def draw_axis_aligned_km_grid(

     def draw_cross_at_intersection(x_px: float, y_px: float) -> None:
         """Рисует крестик в точке пересечения линий сетки."""
-        half = GRID_CROSS_LENGTH_PX // 2
+        cross_len_px = max(1, round(GRID_CROSS_LENGTH_M * ppm))
+        half = max(1, cross_len_px // 2)
         cross_width = 1  # Толщина крестика всегда 1 пиксель
         # Вертикальная линия крестика
         draw.line(
@@ -771,6 +776,8 @@ def draw_elevation_legend(
     center_lat_wgs: float,
     zoom: int,
     scale: int = STATIC_SCALE,
+    title: str | None = None,
+    label_step_m: float | None = None,
 ) -> tuple[int, int, int, int]:
     """
     Рисует адаптивную легенду высот в правом нижнем углу карты.
@@ -791,6 +798,37 @@ def draw_elevation_legend(
         Кортеж (x1, y1, x2, y2) - границы легенды с отступом для разрыва сетки

     """
+    def _wrap_legend_title(
+        draw_obj: ImageDraw.ImageDraw,
+        text: str,
+        title_font: ImageFont.ImageFont,
+        max_width_px: int,
+    ) -> list[str]:
+        def _text_width(candidate: str) -> int:
+            bbox = draw_obj.textbbox((0, 0), candidate, font=title_font, anchor='lt')
+            return bbox[2] - bbox[0]
+
+        words = text.split()
+        if not words:
+            return [text]
+
+        lines: list[str] = []
+        current = ''
+        for word in words:
+            candidate = word if not current else f'{current} {word}'
+            if _text_width(candidate) <= max_width_px:
+                current = candidate
+                continue
+
+            if current:
+                lines.append(current)
+
+            current = word
+
+        if current:
+            lines.append(current)
+        return lines
+
     draw = ImageDraw.Draw(img)
     w, h = img.size

@@ -809,8 +847,10 @@ def draw_elevation_legend(
         # Для больших карт: 10% от высоты
         legend_height = int(h * LEGEND_HEIGHT_RATIO)

-    # Обеспечиваем минимальную читаемость
-    legend_height = max(legend_height, 100)
+    # Ограничиваем высоту легенды долей высоты карты
+    min_legend_height = max(1, int(h * LEGEND_HEIGHT_MIN_RATIO))
+    max_legend_height = max(min_legend_height, int(h * LEGEND_HEIGHT_MAX_RATIO))
+    legend_height = max(min_legend_height, min(legend_height, max_legend_height))

     # Рассчитываем остальные размеры пропорционально высоте легенды
     legend_width = int(legend_height * LEGEND_WIDTH_TO_HEIGHT_RATIO)
@@ -820,6 +860,19 @@ def draw_elevation_legend(
     font_size = int(legend_height * LEGEND_LABEL_FONT_RATIO)
     font_size = max(LEGEND_LABEL_FONT_MIN_PX, min(font_size, LEGEND_LABEL_FONT_MAX_PX))

+    # Загружаем шрифт для подписей и заголовка
+    try:
+        font = load_grid_font(font_size)
+    except Exception:
+        font = ImageFont.load_default()
+
+    title_lines = None
+    title_gap_px = 0
+    title_line_height = 0
+    title_line_gap_px = 0
+    title_block_width = 0
+    title_block_height = 0
+
     # Рассчитываем размер одного квадрата сетки в пикселях
     grid_square_px = GRID_STEP_M * ppm

@@ -849,18 +902,62 @@ def draw_elevation_legend(

     # Рисуем фон легенды (полупрозрачный белый прямоугольник)
     # Фон на 20% больше легенды в обоих направлениях, легенда по центру фона
-    legend_total_width = legend_width + LEGEND_TEXT_OFFSET_PX + text_width_estimate
-    legend_total_height = legend_height
+    text_offset_px = max(1, round(LEGEND_TEXT_OFFSET_M * ppm))
+    legend_total_width = legend_width + text_offset_px + text_width_estimate
+    title_extra_offset_px = 0
+    if title:
+        title_gap_px = max(1, round(LEGEND_TEXT_OFFSET_M * ppm))
+        max_title_width = legend_total_width
+        title_lines = _wrap_legend_title(draw, title, font, max_title_width)
+        title_sizes = [draw.textbbox((0, 0), line, font=font, anchor='lt') for line in title_lines]
+        title_line_height = max(1, max(bbox[3] - bbox[1] for bbox in title_sizes))
+        title_line_gap_px = max(0, round(title_line_height * 0.15))
+        title_block_width = max(bbox[2] - bbox[0] for bbox in title_sizes)
+        title_block_height = title_line_height * len(title_lines) + title_line_gap_px * (len(title_lines) - 1)
+        title_extra_offset_px = max(1, int(legend_height * LEGEND_TITLE_OFFSET_RATIO))
+    legend_total_width = max(legend_total_width, title_block_width)
+    legend_total_height = legend_height + (
+        title_block_height + title_gap_px + title_extra_offset_px if title_lines else 0
+    )

     # Увеличиваем фон на 20% (коэффициент 1.2), добавляя по 10% с каждой стороны
-    bg_padding_x = int(legend_total_width * 0.10)
-    bg_padding_y = int(legend_total_height * 0.10)
+    bg_padding_px = max(1, round(LEGEND_BACKGROUND_PADDING_M * ppm))
+    bg_padding_x = max(int(legend_total_width * 0.10), bg_padding_px)
+    bg_padding_y = max(int(legend_total_height * 0.10), bg_padding_px)
+
+    title_x = legend_x
+    title_y = legend_y
+    if title_lines:
+        title_y = legend_y - title_gap_px - title_block_height - title_extra_offset_px

     bg_x1 = legend_x - bg_padding_x
-    bg_y1 = legend_y - bg_padding_y
+    bg_y1 = title_y - bg_padding_y
     bg_x2 = legend_x + legend_total_width + bg_padding_x
     bg_y2 = legend_y + legend_height + bg_padding_y

+    # Сдвигаем легенду внутрь изображения, если фон выходит за границы
+    shift_x = 0
+    if bg_x1 < 0:
+        shift_x = -bg_x1
+    if bg_x2 + shift_x > w:
+        shift_x = w - bg_x2
+
+    shift_y = 0
+    if bg_y1 < 0:
+        shift_y = -bg_y1
+    if bg_y2 + shift_y > h:
+        shift_y = h - bg_y2
+
+    if shift_x or shift_y:
+        legend_x += shift_x
+        legend_y += shift_y
+        title_x += shift_x
+        title_y += shift_y
+        bg_x1 += shift_x
+        bg_x2 += shift_x
+        bg_y1 += shift_y
+        bg_y2 += shift_y
+
     # Рисуем фон через альфа-композитинг
     if img.mode != 'RGBA':
         # Создаём временное RGBA изображение для наложения фона
@@ -921,29 +1018,42 @@ def draw_elevation_legend(
             )

     # Рисуем рамку вокруг цветовой полосы
+    border_width_px = max(1, round(LEGEND_BORDER_WIDTH_M * ppm))
     draw.rectangle(
         [legend_x, legend_y, legend_x + legend_width, legend_y + legend_height],
         outline=(0, 0, 0),
-        width=LEGEND_BORDER_WIDTH_PX,
+        width=border_width_px,
     )

-    # Добавляем подписи высот
-    try:
-        font = load_grid_font(font_size)
-    except Exception:
-        font = ImageFont.load_default()
+    # Добавляем заголовок легенды
+    if title_lines:
+        title_line_step = title_line_height + title_line_gap_px
+        for index, line in enumerate(title_lines):
+            line_y = title_y + index * title_line_step
+            draw_text_with_outline(
+                draw,
+                (title_x, line_y),
+                line,
+                font=font,
+                fill=(0, 0, 0),
+                outline=(255, 255, 255),
+                outline_width=max(1, round(LEGEND_TEXT_OUTLINE_WIDTH_M * ppm)),
+                anchor='lt',
+            )

     # Рисуем метки высоты
     for i in range(LEGEND_NUM_LABELS):
         t = i / (LEGEND_NUM_LABELS - 1) if LEGEND_NUM_LABELS > 1 else 0.0
         elevation = min_elevation_m + (max_elevation_m - min_elevation_m) * t
+        if label_step_m:
+            elevation = round(elevation / label_step_m) * label_step_m
         label_text = f'{int(elevation)} м'

         # Позиция метки (снизу вверх)
         label_y = legend_y + legend_height - int(t * legend_height)

         # Рисуем текст справа от цветовой полосы с обводкой для читаемости
-        text_x = legend_x + legend_width + LEGEND_TEXT_OFFSET_PX
+        text_x = legend_x + legend_width + text_offset_px
         draw_text_with_outline(
             draw,
             (text_x, label_y),
@@ -951,13 +1061,13 @@ def draw_elevation_legend(
             font=font,
             fill=(0, 0, 0),
             outline=(255, 255, 255),
-            outline_width=LEGEND_TEXT_OUTLINE_WIDTH_PX,
+            outline_width=max(1, round(LEGEND_TEXT_OUTLINE_WIDTH_M * ppm)),
             anchor='lm',
         )

     # Возвращаем границы легенды с отступом для разрыва линий сетки
     # Используем увеличенные размеры фона плюс дополнительный отступ
-    gap_padding = LEGEND_GRID_GAP_PADDING_PX
+    gap_padding = max(1, round(LEGEND_GRID_GAP_PADDING_M * ppm))
     return (
         bg_x1 - gap_padding,
         bg_y1 - gap_padding,
diff --git a/src/service.py b/src/service.py
index ff80730..a617e40 100644
--- a/src/service.py
+++ b/src/service.py
@@ -17,18 +17,18 @@ from pyproj import Transformer
 from constants import (
     ASYNC_MAX_CONCURRENCY,
     CENTER_CROSS_COLOR,
-    CENTER_CROSS_LENGTH_PX,
-    CENTER_CROSS_LINE_WIDTH_PX,
+    CENTER_CROSS_LENGTH_M,
+    CENTER_CROSS_LINE_WIDTH_M,
     CONTOUR_BLOCK_EDGE_PAD_PX,
     CONTOUR_COLOR,
     CONTOUR_INDEX_COLOR,
     CONTOUR_INDEX_EVERY,
     CONTOUR_INDEX_WIDTH,
     CONTOUR_INTERVAL_M,
-    CONTOUR_LABEL_EDGE_MARGIN_PX,
+    CONTOUR_LABEL_EDGE_MARGIN_M,
     CONTOUR_LABEL_GAP_ENABLED,
-    CONTOUR_LABEL_GAP_PADDING,
-    CONTOUR_LABEL_MIN_SEG_LEN_PX,
+    CONTOUR_LABEL_GAP_PADDING_M,
+    CONTOUR_LABEL_MIN_SEG_LEN_M,
     CONTOUR_LABEL_SPACING_M,
     CONTOUR_LABELS_ENABLED,
     CONTOUR_LOG_MEMORY_EVERY_TILES,
@@ -39,6 +39,7 @@ from constants import (
     CONTROL_POINT_SIZE_M,
     DOWNLOAD_CONCURRENCY,
     EARTH_RADIUS_M,
+    ELEVATION_LEGEND_STEP_M,
     ELEVATION_USE_RETINA,
     GRID_COLOR,
     GRID_STEP_M,
@@ -469,10 +470,15 @@ async def download_satellite_rectangle(
                     p_hi=ELEV_PCTL_HI,
                     min_range_m=ELEV_MIN_RANGE_M,
                 )
-                inv = 1.0 / (hi - lo) if hi > lo else 0.0
+                step_m = ELEVATION_LEGEND_STEP_M
+                lo_rounded = math.floor(lo / step_m) * step_m
+                hi_rounded = math.ceil(hi / step_m) * step_m
+                if hi_rounded <= lo_rounded:
+                    hi_rounded = lo_rounded + step_m
+                inv = 1.0 / (hi_rounded - lo_rounded)
                 # Сохраняем диапазон высот для легенды
-                elev_min_m = lo
-                elev_max_m = hi
+                elev_min_m = lo_rounded
+                elev_max_m = hi_rounded

                 # Pass B: render directly to output image using cached tiles (no network)
                 result = Image.new('RGB', (crop_rect[2], crop_rect[3]))
@@ -515,7 +521,7 @@ async def download_satellite_rectangle(
                     ar = 0.1 * 65536.0 * inv
                     ag = 0.1 * 256.0 * inv
                     ab = 0.1 * 1.0 * inv
-                    a0 = (-10000.0 - lo) * inv
+                    a0 = (-10000.0 - lo_rounded) * inv

                     while True:
                         item = await queue.get()
@@ -918,15 +924,20 @@ async def download_satellite_rectangle(
                             logger.warning(
                                 'Подписи изогипс: dry_run вернул 0 кандидатов — проверьте пороги (spacing=%d,min_len=%d,edge=%d) и геометрию полилиний',
                                 int(CONTOUR_LABEL_SPACING_M),
-                                int(CONTOUR_LABEL_MIN_SEG_LEN_PX),
-                                int(CONTOUR_LABEL_EDGE_MARGIN_PX),
+                                int(CONTOUR_LABEL_MIN_SEG_LEN_M),
+                                int(CONTOUR_LABEL_EDGE_MARGIN_M),
                             )

                         # Создаем разрывы линий контуров в местах подписей

                         if CONTOUR_LABEL_GAP_ENABLED and label_bboxes:
                             draw = ImageDraw.Draw(result)
-                            gap_padding = int(CONTOUR_LABEL_GAP_PADDING)
+                            gap_padding = max(
+                                1,
+                                round(
+                                    CONTOUR_LABEL_GAP_PADDING_M / max(1e-9, mpp)
+                                ),
+                            )
                             for bbox in label_bboxes:
                                 x0, y0, x1, y1 = bbox
                                 # Расширяем область на gap_padding
@@ -1513,7 +1524,10 @@ async def download_satellite_rectangle(

                     if CONTOUR_LABEL_GAP_ENABLED and overlay_label_bboxes:
                         draw_overlay = ImageDraw.Draw(overlay)
-                        gap_padding = int(CONTOUR_LABEL_GAP_PADDING)
+                        gap_padding = max(
+                            1,
+                            round(CONTOUR_LABEL_GAP_PADDING_M / max(1e-9, mpp)),
+                        )
                         for bbox in overlay_label_bboxes:
                             x0, y0, x1, y1 = bbox
                             # Расширяем область на gap_padding
@@ -1655,6 +1669,8 @@ async def download_satellite_rectangle(
                 center_lat_wgs=center_lat_wgs,
                 zoom=zoom,
                 scale=eff_scale,
+                title='Высота',
+                label_step_m=ELEVATION_LEGEND_STEP_M,
             )
             legend_elapsed = time.monotonic() - legend_start_time
             logger.info('Рисование легенды высот — завершено (%.2fs)', legend_elapsed)
@@ -1674,6 +1690,8 @@ async def download_satellite_rectangle(
                 center_lat_wgs=center_lat_wgs,
                 zoom=zoom,
                 scale=eff_scale,
+                title='Минимальная высота БпЛА',
+                label_step_m=ELEVATION_LEGEND_STEP_M,
             )
             legend_elapsed = time.monotonic() - legend_start_time
             logger.info(
@@ -1705,10 +1723,13 @@ async def download_satellite_rectangle(
         )

         # Draw the cross at the image center
+        mpp_center = meters_per_pixel(center_lat_wgs, zoom, scale=eff_scale)
+        ppm_center = 1.0 / mpp_center if mpp_center > 0 else 0.0
         cx = result.width // 2
         cy = result.height // 2
-        half = max(1, int(CENTER_CROSS_LENGTH_PX) // 2)
-        line_w = max(1, int(CENTER_CROSS_LINE_WIDTH_PX))
+        length_px = max(1, round(CENTER_CROSS_LENGTH_M * ppm_center))
+        half = max(1, length_px // 2)
+        line_w = max(1, round(CENTER_CROSS_LINE_WIDTH_M * ppm_center))
         draw = ImageDraw.Draw(result)
         color = tuple(CENTER_CROSS_COLOR)
         draw.line([(cx, cy - half), (cx, cy + half)], fill=color, width=line_w)
diff --git a/src/topography.py b/src/topography.py
index 3e6cd20..70c33bb 100644
--- a/src/topography.py
+++ b/src/topography.py
@@ -16,6 +16,7 @@ from pyproj.transformer import TransformerGroup
 from constants import (
     EARTH_RADIUS_M,
     EAST_VECTOR_SAMPLE_M,
+    ELEVATION_LEGEND_STEP_M,
     ELEV_MIN_RANGE_M,
     ELEV_PCTL_HI,
     ELEV_PCTL_LO,
@@ -680,13 +681,19 @@ def colorize_dem_to_image(
         lo = mid - min_range_m / 2.0
         hi = mid + min_range_m / 2.0

+    step_m = ELEVATION_LEGEND_STEP_M
+    lo_rounded = math.floor(lo / step_m) * step_m
+    hi_rounded = math.ceil(hi / step_m) * step_m
+    if hi_rounded <= lo_rounded:
+        hi_rounded = lo_rounded + step_m
+
     # Строим LUT
     lut_size = 2048
     lut = _build_elevation_lut(ELEVATION_COLOR_RAMP, lut_size)

     # Нормализация и индексация — полностью векторизовано
-    inv_range = (lut_size - 1) / (hi - lo) if hi > lo else 0.0
-    indices = ((dem_arr - lo) * inv_range).astype(np.int32)
+    inv_range = (lut_size - 1) / (hi_rounded - lo_rounded) if hi_rounded > lo_rounded else 0.0
+    indices = ((dem_arr - lo_rounded) * inv_range).astype(np.int32)
     indices = np.clip(indices, 0, lut_size - 1)

     # Применяем LUT — векторизованная операция