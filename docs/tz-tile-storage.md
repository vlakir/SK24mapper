# ТЗ: Тайловое хранение карт в SQLite

## 1. Цель

Реализовать систему тайлового хранения, которая позволит:
- Загружать карты любого размера без ограничений по памяти
- Кэшировать загруженные тайлы для повторного использования
- Экспортировать карты в TIFF/JPEG

## 2. Текущая архитектура (проблемы)

```
Mapbox API → HTTP Cache (SQLite) → StreamingImage (mmap) → TIFF/JPEG
                                         ↑
                              Ограничение: весь файл создаётся сразу
```

**Проблемы:**
- mmap файл создаётся целиком до начала скачивания
- Для карты 100k×70k пикселей = 20GB файл → зависание
- HTTP кэш хранит сырые ответы API, не оптимизирован для тайлов
- Нет возможности докачать часть карты
- Отдельный кэш для elevation тайлов

## 3. Новая архитектура

```
Mapbox API → TileFetcher → [Queue] → TileCache (SQLite по zoom)
                                           ↓
                              TileAssembler → TIFF/JPEG
                                           ↓
                              OverviewGenerator (lazy)
```

### 3.1. Структура файлов кэша

```
.cache/
├── tiles/
│   ├── zoom_14.db      # Тайлы zoom 14
│   ├── zoom_15.db      # Тайлы zoom 15
│   ├── ...
│   ├── zoom_20.db      # Тайлы zoom 20
│   └── overview.db     # Автогенерируемые overview уровни
```

**Преимущества разделения по zoom:**
- Можно удалить один zoom и освободить много места
- Меньше размер каждой БД → быстрее операции
- Параллельная запись в разные файлы

### 3.2. Схема БД (для каждого zoom_N.db)

```sql
-- Метаданные
CREATE TABLE metadata (
    name TEXT PRIMARY KEY,
    value TEXT
);

-- Тайлы
CREATE TABLE tiles (
    x INTEGER NOT NULL,           -- X (XYZ система)
    y INTEGER NOT NULL,           -- Y (XYZ система)
    source TEXT NOT NULL,         -- 'satellite', 'terrain-rgb', 'streets', etc.
    tile_data BLOB NOT NULL,      -- JPEG/PNG данные (raw от API)
    fetched_at INTEGER NOT NULL,  -- Unix timestamp загрузки
    last_used_at INTEGER NOT NULL,-- Unix timestamp последнего использования (для LRU)
    size_bytes INTEGER NOT NULL,  -- Размер данных
    PRIMARY KEY (x, y, source)
);

CREATE INDEX idx_tiles_last_used ON tiles(last_used_at);
CREATE INDEX idx_tiles_source ON tiles(source);
```

### 3.3. TileCache — работа с кэшем

**Основные операции:**
- `get(zoom, x, y, source)` → bytes | None
- `put(zoom, x, y, source, data)` → None
- `get_multi(tiles: list)` → dict  # Batch операция
- `cleanup_lru(max_size_mb)` → int  # Возвращает освобождённый размер
- `get_stats()` → CacheStats  # Статистика по zoom уровням

**Особенности:**
- Один writer thread с очередью записи
- Много reader threads (параллельное чтение)
- WAL режим для SQLite
- Обновление `last_used_at` при чтении (для LRU)

### 3.4. TileFetcher — скачивание тайлов

**Логика:**
1. Проверить кэш
2. Если нет или истёк TTL → скачать с API
3. Retry 3 раза с экспоненциальной задержкой
4. Поставить в очередь записи в кэш
5. Вернуть данные

**Параллельность:**
- До 40 параллельных HTTP запросов
- Один writer thread для SQLite
- Очередь между fetcher и writer

### 3.5. TileAssembler — сборка карты

**Режимы работы:**

| Размер карты | Режим | Описание |
|--------------|-------|----------|
| < 100M px | Полная сборка | Собираем в память, применяем все эффекты |
| ≥ 100M px | Потоковая | Пишем в TIFF по полосам, оверлеи пропускаем |

### 3.6. OverviewGenerator — preview уровни

**Генерация по требованию (lazy):**
- При первом просмотре карты
- Создаём уменьшенные zoom уровни из существующих тайлов
- Храним в `overview.db`

### 3.7. TileRenderer — динамическое превью

**Принцип работы:**
- Отображаем только видимую область окна превью
- Zoom уровень тайлов выбирается по масштабу отображения
- При масштабировании мгновенно переключаемся на другой zoom

**Алгоритм отрисовки:**
```
1. Определить видимую область (viewport) в координатах карты
2. Вычислить оптимальный zoom для текущего масштаба отображения
3. Определить какие тайлы покрывают viewport
4. Для каждого тайла:
   a. Есть в кэше → отрисовать
   b. Нет в кэше → отрисовать placeholder из меньшего zoom
   c. Запустить фоновую загрузку недостающих
5. При получении тайла → обновить только его область
```

**Оптимизация памяти:**
- В памяти только тайлы видимой области + небольшой буфер
- При панорамировании — выгружаем невидимые, загружаем новые
- LRU кэш декодированных тайлов (~50-100 штук)

## 4. Принятые решения

| # | Вопрос | Решение |
|---|--------|---------|
| 1 | Координаты тайлов | XYZ (как Mapbox) |
| 2 | Формат хранения | Raw от API (JPEG/PNG) |
| 3 | Политика очистки | LRU по размеру |
| 4 | Макс. размер кэша | 20 GB (константа) |
| 5 | Экспорт MBTiles | Не нужен |
| 6 | Overview уровни | Lazy генерация при просмотре |
| 7 | Параллельность | Много readers, один writer через очередь |
| 8 | Ошибки скачивания | Retry 3 раза, потом пропустить |
| 9 | Elevation данные | Raw PNG (декодируем при использовании) |
| 10 | Офлайн режим | Да, нужен |
| 11 | Инвалидация | TTL + LRU |
| 12 | Файлы БД | По zoom уровням |
| 13 | Старый HTTP кэш | Удалить полностью |
| 14 | ElevationTileProvider | Объединить с TileCache |
| 15 | Выбор zoom | Автовыбор + возможность переопределить |
| 16 | Сохранение zoom | В TOML профиле (detail_level) |
| 17 | Превью | Динамическое — zoom по масштабу отображения |
| 18 | Память превью | Только видимые тайлы + LRU буфер |

## 5. Изменения в коде

### 5.1. Новые модули

```
src/tiles/
├── __init__.py
├── cache.py           # TileCache — SQLite операции
├── fetcher.py         # TileFetcher — HTTP + кэш логика
├── assembler.py       # TileAssembler — сборка карты
├── writer.py          # CacheWriter — writer thread + очередь
├── overview.py        # OverviewGenerator — lazy overview
└── renderer.py        # TileRenderer — динамическое превью
```

### 5.2. Удаляемые модули

```
src/infrastructure/http/client.py   # Заменяется на TileFetcher
src/elevation/provider.py           # Объединяется с TileCache
```

### 5.3. Изменения в существующих модулях

| Модуль | Изменения |
|--------|-----------|
| `services/processors/xyz_tiles.py` | Использовать TileFetcher |
| `services/processors/elevation_*.py` | Использовать TileFetcher |
| `services/map_download_service.py` | Использовать TileAssembler |
| `elevation/dem_builder.py` | Получать тайлы через TileFetcher |

### 5.4. Константы

```python
# shared/constants.py

# Директория кэша тайлов
TILE_CACHE_DIR = '.cache/tiles'

# Максимальный размер кэша (MB)
TILE_CACHE_MAX_SIZE_MB = 20_000  # 20 GB

# TTL кэша (часы) — после этого тайл "желательно обновить"
TILE_CACHE_TTL_HOURS = 168  # 7 дней

# Порог для потоковой сборки (пиксели)
TILE_ASSEMBLY_STREAMING_THRESHOLD = 100_000_000  # 100M px

# Параллельность скачивания
TILE_FETCH_CONCURRENCY = 40

# Размер очереди записи
TILE_WRITE_QUEUE_SIZE = 1000

# Порог для автовыбора zoom (MB) — zoom выбирается чтобы файл был меньше
AUTO_ZOOM_TARGET_SIZE_MB = 500
```

## 6. UI изменения

### 6.1. Выбор детализации (zoom)

**Логика автовыбора:**
- Вычисляем оптимальный zoom чтобы итоговый файл был < 500 MB
- Не превышаем максимум провайдера (обычно 20)

**UI:**
```
Детализация: [▼ Авто (0.3 м/пикс, ~4000 тайлов) ]
             ├─ Авто — оптимальный для размера карты
             ├─ Максимальная (0.15 м/пикс)
             ├─ Высокая (0.3 м/пикс)
             ├─ Средняя (0.6 м/пикс)
             └─ Низкая (1.2 м/пикс)
```

**Сохранение в профиле (TOML):**
```toml
[map]
# 'auto', 'max', 'high', 'medium', 'low' или конкретный zoom (14-20)
detail_level = "auto"
```

**Маппинг уровней на zoom:**
| Уровень | Примерный zoom | м/пиксель |
|---------|----------------|-----------|
| max | 20 | ~0.15 |
| high | 19 | ~0.3 |
| medium | 18 | ~0.6 |
| low | 17 | ~1.2 |

### 6.2. Другие опции

- **Офлайн режим:** чекбокс "Работать только из кэша"
- **Статистика кэша:** размер по zoom уровням
- **Очистка кэша:** выбор zoom уровней для удаления

### 6.3. Прогресс загрузки

```
Загрузка тайлов: 245/1024 (кэш: 180, новые: 65)
[████████░░░░░░░░░░░░] 24%
```

## 7. План реализации

### Этап 1: Базовая инфраструктура
1. Создать `src/tiles/cache.py` — TileCache
2. Создать `src/tiles/writer.py` — CacheWriter (очередь)
3. Тесты для cache и writer

### Этап 2: Скачивание тайлов
4. Создать `src/tiles/fetcher.py` — TileFetcher
5. Интегрировать с TileCache
6. Тесты для fetcher

### Этап 3: Интеграция в процессоры
7. Обновить `xyz_tiles.py`
8. Обновить `elevation_color.py`, `elevation_contours.py`
9. Обновить `radio_horizon.py`
10. Тесты процессоров

### Этап 4: Сборка карты
11. Создать `src/tiles/assembler.py`
12. Обновить `map_download_service.py`
13. Тесты assembler

### Этап 5: Preview и UI
14. Создать `src/tiles/overview.py` — lazy overview генерация
15. Создать `src/tiles/renderer.py` — динамическое превью
16. Интегрировать TileRenderer в preview_window.py
17. Добавить UI опции (офлайн, статистика, очистка, выбор детализации)
18. Интеграционные тесты

### Этап 6: Очистка
19. Удалить старый HTTP кэш код
20. Удалить ElevationTileProvider
21. Финальное тестирование

## 8. Риски и митигация

| Риск | Митигация |
|------|-----------|
| SQLite блокировки | WAL режим + один writer thread |
| Потеря данных при краше | Транзакции, fsync после batch |
| Переполнение очереди | Ограничение размера, backpressure |
| Медленный LRU cleanup | Фоновый процесс, инкрементальная очистка |

---

**Статус:** Готово к реализации
**Дата:** 2026-02-03
