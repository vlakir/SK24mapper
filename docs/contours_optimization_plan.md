Практичный план оптимизации режима «Карта высот (контуры)»

Цель
- Сделать производительность режима «Контуры» сопоставимой с «Цветовой шкалой», сохранив текущую архитектуру: два прохода, потоковую загрузку, producer/consumer, DRY.

Ключевые проблемы текущей реализации
- Декодирование DEM из Terrain‑RGB выполняется чисто на Python (вложенные циклы) — высокий CPU overhead.
- Marching squares выполняется для всех уровней на каждом блоке — нет отсечки уровней по блочному min/max.
- Рисование линий делается непосредственно на общий холст под глобальной блокировкой — воркеры фактически сериализуются.
- Много мелких вызовов draw.line на общий холст.

Предлагаемые улучшения (по приоритету)
1) Векторизация декодирования DEM в consumer2
- Вместо decode_terrain_rgb_to_elevation_m(img):
  - arr = np.asarray(img, dtype=np.uint8)  # HxWx3
  - dem_full = -10000.0 + (
      arr[...,0].astype(np.float32) * 65536.0 +
      arr[...,1].astype(np.float32) * 256.0 +
      arr[...,2].astype(np.float32)
    ) * 0.1
  - sub = dem_full[y_off:y_off+block_h, x_off:x_off+block_w]
- Эффект: значительное снижение CPU на этапе подготовки данных для marching squares.

2) Сократить время под paste_lock до одного вызова на блок
- Рисовать не на общий result, а в локальный прозрачный буфер блока:
  - tmp = Image.new('RGBA', (block_w, block_h), (0,0,0,0))
  - draw = ImageDraw.Draw(tmp)
  - отрисовать все линии уровнями на tmp
  - затем под замком ОДИН раз: result.alpha_composite(tmp, (dx0, dy0))
    или result.paste(tmp, (dx0, dy0), tmp)
- Эффект: реальный параллелизм CPU‑воркеров, исчезновение длинных критических секций.

3) Быстрый отсев уровней «не по месту» (per‑block)
- Для sub вычислить mn, mx = sub.min(), sub.max().
- Обрабатывать только уровни L, где mn <= L <= mx.
- Эффект: L сокращается на 70–95% для большинства блоков; снижение сложности до O(W*H*L_block), где L_block << L_global.

4) Адаптировать шаг изогипс к масштабу
- Привязать минимальную «визуальную» частоту линий к meters_per_pixel (см. topography.meters_per_pixel):
  - не чаще 1 линия на 8–12 пикселей по вертикали/горизонтали.
- Ввести верхний предел на количество уровней L (например, ≤ 60) — при превышении увеличивать интервал.
- Эффект: контролируемая сложность на больших сценах/высоких зумах, без потери читаемости.

5) Уменьшить число вызовов draw.line
- По возможности объединять сегменты в полилинии по связности (опционально).
- Даже без объединения перенос рисования в локальный буфер и один paste даёт большой выигрыш.

6) Микрооптимизации marching squares
- Локальные ссылки на часто используемые объекты/функции.
- Минимизировать проверку границ; не обрабатывать правую/нижнюю границу, если она будет покрыта соседним тайлом.
- Обработку случаев 5/10 (двусмысленность) оставить как сейчас или упростить, ориентируясь на качество.

7) Параллелизм
- После сокращения критических секций поднять число CPU‑воркеров до min(os.cpu_count(), 6–8).
- Подобрать размер очереди (например, maxsize=8), чтобы не давить память и не простаивать.

План внедрения по шагам
- Шаг 1: Векторизация DEM + локальный буфер рисования + один paste (ядро выигрыша)
  - Риски: зависимость от NumPy (защититься флагом USE_NUMPY_FASTPATH, падать в Python‑ветку при отсутствии).
- Шаг 2: Отсев уровней per‑block по mn/mx
  - Риски: корректность на границах; протестировать граничные блоки (равнины, горы).
- Шаг 3: Адаптивный шаг изогипс (+ верхний предел L)
  - Настроить параметры по умолчанию (например, 10 px/линию, максимум 60 уровней).
- Шаг 4: Микрооптимизации и, при желании, объединение сегментов в полилинии
  - Протестировать эффект vs сложность.
- Шаг 5: Подбор параллелизма и параметров очереди

Критерии приёмки
- Время построения «Контуров» сопоставимо с «Цветовой шкалой» на тех же сценах (одно и то же окно/зум), различие не более чем в 1.5–2x при разумном числе уровней.
- Под замком paste_lock в среднем один заход на тайл (один paste/composite).
- Визуально: отсутствуют разрывы на швах, каждая 5‑я изогипса выделена (цвет/толщина), шаг выдержан.
- Память и устойчивость не хуже, чем в «Цветовой шкале» для той же площади.

Метрики и проверка
- Замерять время Pass B до/после на:
  - горный регион; равнина; средний рельеф;
  - маленькая и средняя область; с/без @2x.
- Логировать: количество уровней до/после отсечки per‑block; средний/макс L_block.
- Логировать число заходов под замок/блок (должно быть ~1).
- Визуально проверить швы между блоками и корректность уровней.

Обратная совместимость и риски
- При отсутствии NumPy использовать текущую Python‑ветку (медленнее, но корректно).
- Не логировать токен; сохранить поведение кэша и лимиты параллелизма.

Долгосрочные улучшения (необязательно для MVP)
- Построение полилиний и их упрощение (Douglas–Peucker) для уменьшения числа сегментов.
- Опциональные подписи высот вдоль «индексных» изогипс.
- В дальнейшем — возможность наложения контуров поверх светлой подложки (multiply) и/или совместный режим с цветовой шкалой.
